import{_ as e,c as r,o,ae as a}from"./chunks/framework.BQlYxExx.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mysql/index.md","filePath":"mysql/index.md","lastUpdated":null}'),i={name:"mysql/index.md"};function t(n,l,E,h,p,s){return o(),r("div",null,[...l[0]||(l[0]=[a('<blockquote><p>食用指南：</p><p>1、选择一个知识点</p><p>2、阅读知识点对应的“必学资料”</p><p>3、背题</p></blockquote><blockquote><p>ps：</p><p>1、答案由 AI 生成，仅供参考。</p><p>2、个人认为背题最合理的方式是参透题目背后的知识点，用自己的语言组织出答案，只有这样才能将知识点内化于心，面试时游刃有余。</p><p>3、针对第二步，个人认为不是必需项。你完全可以直接开始背题，如果在背题过程中有疑问大可请教 AI，但如果你想深入了解底层原理，广泛阅读和深度思考是必不可少的。</p><p>4、在面试、看面经过程中注意多多积累，形成自己的专属题库。</p></blockquote><h2 id="🧭-目录" tabindex="-1">🧭 目录 <a class="header-anchor" href="#🧭-目录" aria-label="Permalink to &quot;🧭 目录&quot;">​</a></h2><ul><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%B8%80sql-%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%8C%83%E5%BC%8F" target="_blank" rel="noreferrer">一、SQL 基础与范式</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%BA%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noreferrer">二、存储引擎与数据类型</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%B8%89%E7%B4%A2%E5%BC%95%E9%87%8D%E7%82%B9" target="_blank" rel="noreferrer">三、索引（重点）</a><ul><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#1-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">1. 索引原理</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#2-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" target="_blank" rel="noreferrer">2. 索引类型</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#3-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" target="_blank" rel="noreferrer">3. 索引优化与执行计划</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#4-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%AE%9E%E6%88%98%E9%A2%98" target="_blank" rel="noreferrer">4. 联合索引与实战题</a></li></ul></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E5%9B%9B%E4%BA%8B%E5%8A%A1%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D" target="_blank" rel="noreferrer">四、事务（重中之重）</a><ul><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#1-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7" target="_blank" rel="noreferrer">1. 事务特性</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#2-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98" target="_blank" rel="noreferrer">2. 隔离级别与并发问题</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#3-mvcc" target="_blank" rel="noreferrer">3. MVCC</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96" target="_blank" rel="noreferrer">4. 事务日志与持久化</a></li></ul></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%BA%94%E9%94%81%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">五、锁机制</a><ul><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#1-%E9%94%81%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">1. 锁分类与原理</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#2-%E6%AD%BB%E9%94%81%E4%B8%8E%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90" target="_blank" rel="noreferrer">2. 死锁与冲突分析</a></li></ul></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E5%85%AD%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F" target="_blank" rel="noreferrer">六、日志系统</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%B8%83%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noreferrer">七、性能优化</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E5%85%AB%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E6%89%A9%E5%B1%95" target="_blank" rel="noreferrer">八、高可用与扩展</a></li><li><a href="https://www.yuque.com/lyydsheep/kyeikv/oty7gnbriyqs9cro#%E4%B9%9D%E7%BB%BC%E5%90%88%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98" target="_blank" rel="noreferrer">九、综合与思考题</a></li></ul><hr><h2 id="一、sql-基础与范式-🌟" tabindex="-1">一、SQL 基础与范式（🌟） <a class="header-anchor" href="#一、sql-基础与范式-🌟" aria-label="Permalink to &quot;一、SQL 基础与范式（🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><h3 id="必学资料" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><h3 id="面试题逐题回答" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>数据库三大范式是什么？<br> 第一范式要求字段不可再分，这是关系型的底线；第二范式在满足 1NF 基础上，要求非主属性必须完全依赖整个主键，消除部分依赖；第三范式进一步要求任何非主属性不能传递依赖于主键，即消除‘主键→A→B’的传递路径。实际项目中，为了查询性能或统计方便，有时会反范式化，但必须先理解范式，再决定破坏哪一级。</li></ol><hr><ol start="2"><li>主键设计的原则是什么？为什么不推荐使用有业务含义的主键？<br> 我遵循四项原则：无业务含义、不可变、短整型优先、单列有序。业务字段如手机号、订单号可能重复、变更或需要格式化，一旦变更会级联影响所有关联表；同时字符串长、随机性高，二级索引叶子节点变大，内存与 IO 都会放大。所以我一直用 bigint 自增或雪花 ID，把业务唯一约束交给唯一索引。</li></ol><hr><ol start="3"><li>主键应使用自增 ID 还是 UUID？各自优缺点？<br> 自增 ID 有序、长度短 8 字节，B+ 树顺序插入页分裂少，范围分页友好；缺点是分库分表后可能冲突、可预测性强。UUID 全局唯一、安全、适合分布式；但 36 字节字符串，主键和二级索引都膨胀，随机写入导致页分裂与磁盘离散 IO，QPS 高时瓶颈明显。我的折中方案是雪花 ID：64 位有序 long，既保持顺序又支持分布式。</li></ol><hr><ol start="4"><li>如果不定义主键会发生什么？<br> InnoDB 必须有一个聚簇索引，如果建表时没有主键也没有非空唯一索引，会隐式追加 6 字节 row_id 列做聚簇键。这个隐藏列全局共享，高并发插入容易成为瓶颈，且复制到从库时行定位不确定，可能导致主从不一致。所以线上规范强制每张表显式指定主键。</li></ol><hr><ol start="5"><li>外键约束是什么？<br> 外键是表与表之间的参照完整性约束，定义在从表上，要求插入或更新的列值必须存在于主表的对应列，支持级联更新或删除。它把关系模型里的‘引用’语义变成数据库强制执行的行为。</li></ol><hr><ol start="6"><li>外键的优缺点？为什么互联网项目常禁用外键？<br> 优点是能保证数据一致性，省掉部分校验代码。缺点是：1) 高并发写入时会在主表加共享锁，甚至级联锁，放大锁范围；2) 批量导入、在线 DDL 需按依赖顺序操作，维护成本高；3) 分库分表后跨库无法生效；4) 故障排查时级联删除难以回滚。因此我们在应用层做‘逻辑外键’：代码先查再插，删除前校验，配合定时任务兜底。</li></ol><hr><ol start="7"><li>字段为什么建议定义为 NOT NULL？<br> NULL 会让 count(col) 跳过该行，导致业务统计异常；B+ 树索引不会存储 NULL，范围查询需要回表；同时查询条件 IS NULL 无法使用覆盖索引。更关键的是 MySQL 对 NULL 采用三值逻辑（true/false/unknown），组合条件容易踩坑。除非业务语义确实需要‘未知’，否则一律给默认值并 NOT NULL。</li></ol><hr><ol start="8"><li>truncate、delete、drop 区别？<br> truncate 是 DDL，按页整体回收，不写逐行日志，自增计数器重置，速度快但不能带 where；delete 是 DML，逐行加锁写 undo/redo，可回滚，可带条件；drop 直接把表定义和数据文件一起移除，不可回滚。线上清理全表数据优先 truncate，但触发器、外键存在时会退化为 delete，要注意行锁风险。</li></ol><hr><ol start="9"><li>union 和 union all 的区别？<br> union 会在临时表上做 distinct 去重并排序，代价是额外的一次哈希或排序；union all 只是把两个结果集简单拼接，不去重也不排序，性能高。如果业务语义保证两边无重复，或允许重复，一律用 union all，把去重逻辑放到代码或冗余唯一索引里。</li></ol><hr><ol start="10"><li>JOIN 有几种？INNER / LEFT / RIGHT / CROSS 的区别？<br> 四种常见连接：inner join 只返回两边匹配的行；left join 返回左表全部行，右表无匹配补 NULL；right join 相反；cross join 是笛卡尔积，无连接条件。执行计划里驱动表选择会影响性能：小表驱动大表可利用 Nested-Loop，把大表走索引；left join 通常左表为驱动，禁止把左表做大表。</li></ol><hr><ol start="11"><li>子查询与连接查询性能差异？<br> 相关子查询会对外表每一行都执行一次子查询，复杂度 O(n²)，在 5.5 之前是灾难；派生表（from 里的子查询）会物化到临时表，无索引，大数据量会落盘。改写成 join 后优化器可以选驱动表、用索引、做 hash join，复杂度降到 O(n)。线上规范要求把 in/exists 相关子查询全部改写成 join 或半连接。</li></ol><hr><ol start="12"><li>临时表与派生表的区别？<br> 临时表分两种：一是用户显式 create temporary table，会话级可见，可建索引，用完自动回收；二是优化器在执行过程中生成的派生表（derived table），来自子查询或 union，5.7 之前会物化到磁盘临时表且无索引，成为性能黑洞。8.0 已支持 derived condition pushdown 和 hash join，但仍建议大结果集先手动存临时表并加索引。</li></ol><hr><ol start="13"><li>视图（View）与物化视图的区别？<br> 普通视图是存储的 select 语句，每次访问都重新执行，数据实时但性能取决于底层查询；物化视图把结果集物理落表，可建索引，查询直接扫表，速度快，但需要刷新机制。MySQL 原生只提供普通视图，物化视图需用触发器或定时任务手动实现。对报表类慢查询，我会用物化视图+增量刷新，把 30s 的复杂 join 降到 200ms。</li></ol><hr><ol start="14"><li>一条 SQL 语句的执行过程</li></ol><p>在 MySQL 中，一条 SQL 语句从执行到返回结果大致经历以下过程：客户端首先通过连接器建立连接并完成身份认证，SQL 语句进入服务层后由解析器进行语法分析和语义校验，再经过优化器生成最优的执行计划，随后执行器根据计划调用存储引擎（如 InnoDB）读取或写入数据，最后将结果返回给客户端。在这个过程中，查询优化器决定了 SQL 的执行效率，而存储引擎负责真正的数据存取与事务控制。</p><h2 id="二、存储引擎与数据类型-🌟" tabindex="-1">二、存储引擎与数据类型（🌟） <a class="header-anchor" href="#二、存储引擎与数据类型-🌟" aria-label="Permalink to &quot;二、存储引擎与数据类型（🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-1" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-1" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><ul><li><strong>InnoDB事务行锁，MyISAM表锁快</strong></li><li><strong>Memory内存存表，断电数据丢</strong></li><li><strong>InnoDB日志支持ACID，MyISAM无事务</strong></li><li><strong>在线DDL，InnoDB边改边读</strong></li><li><strong>索引锁表看引擎，InnoDB可在线</strong></li><li><strong>CHAR定长快，VARCHAR变长省</strong></li><li><strong>DATETIME不受时区，TIMESTAMP随区转</strong></li><li><strong>小精准类型优，冗余大文本避</strong></li></ul><h3 id="必学资料-1" tabindex="-1"><strong>必学资料</strong> <a class="header-anchor" href="#必学资料-1" aria-label="Permalink to &quot;**必学资料**&quot;">​</a></h3><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/01%20%20%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b%ef%bc%9a%e9%81%bf%e5%85%8d%e8%87%aa%e5%a2%9e%e8%b8%a9%e5%9d%91.md" target="_blank" rel="noreferrer">01 数字类型：避免自增踩坑</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/02%20%20%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%ef%bc%9a%e4%b8%8d%e8%83%bd%e5%bf%bd%e7%95%a5%e7%9a%84%20COLLATION.md" target="_blank" rel="noreferrer">02 字符串类型：不能忽略的 COLLATION</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/03%20%20%e6%97%a5%e6%9c%9f%e7%b1%bb%e5%9e%8b%ef%bc%9aTIMESTAMP%20%e5%8f%af%e8%83%bd%e6%98%af%e5%b7%a8%e5%9d%91.md" target="_blank" rel="noreferrer">03 日期类型：TIMESTAMP 可能是巨坑</a></p><h3 id="面试题逐题回答-1" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-1" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>MySQL 常见存储引擎有哪些？</li></ol><p>MySQL 常见的存储引擎主要有 InnoDB、MyISAM 和 Memory。InnoDB 是默认引擎，支持事务和行级锁，适合大多数业务场景；MyISAM 不支持事务，但读操作速度快，适合统计或分析型业务；Memory 存储在内存中，速度极快，但数据断电后会丢失，通常用于临时表和缓存。</p><hr><ol start="2"><li>各存储引擎的区别与应用场景？</li></ol><p>InnoDB 与 MyISAM 的核心区别在于事务支持、锁粒度和数据安全。InnoDB 支持事务（ACID）、行级锁和外键，崩溃恢复能力强，适合高并发读写和数据完整性要求高的场景。MyISAM 不支持事务、只支持表级锁，读取速度快，适合读多写少或报表分析场景。Memory 引擎速度最快，但数据存储在内存中，适合临时表或缓存场景。</p><hr><ol start="3"><li>InnoDB 为什么支持事务？MyISAM 为什么不支持？</li></ol><p>InnoDB 支持事务是因为其实现了 undo log、redo log 和锁机制，保证了事务的原子性、一致性、隔离性和持久性（ACID）。MyISAM 不支持事务，主要是设计上只关注高效的读写性能，没有实现日志和行级锁机制，因此无法保证事务回滚或一致性。</p><hr><ol start="4"><li>在线修改表结构（DDL）时会发生什么？</li></ol><p>执行 <code>ALTER TABLE</code> 修改表结构时，MySQL 会根据存储引擎选择不同策略。InnoDB 支持 在线 DDL，在大多数修改操作下可以边读写边修改（但写操作可能有轻微阻塞）；MyISAM 则通常会锁表，整个表不可读写，直到操作完成。DDL 还可能触发表复制、索引重建和元数据更新。</p><hr><ol start="5"><li>创建索引时是否会锁表？</li></ol><p>是否锁表取决于存储引擎和 MySQL 版本。InnoDB 在现代版本中支持 在线创建索引（ONLINE=TRUE），可以在大多数读写操作同时进行，但部分写操作可能被短暂阻塞；MyISAM 创建索引时会锁表，整个表在索引构建期间不可操作。</p><hr><ol start="6"><li>CHAR 和 VARCHAR 的区别？</li></ol><p>CHAR 是固定长度字段，存储效率高但可能浪费空间；VARCHAR 是可变长度字段，节省空间但在修改或排序时性能略低。选择时，如果字段长度固定（如身份证号、性别），用 CHAR；长度不固定（如用户名、邮箱），用 VARCHAR。</p><hr><ol start="7"><li>DATETIME 和 TIMESTAMP 的区别？</li></ol><p>DATETIME 存储完整日期时间（&#39;YYYY-MM-DD HH:MM:SS&#39;），不受时区影响；TIMESTAMP 存储自 1970-01-01 UTC 起的秒数，会根据系统时区自动转换。DATETIME 占用 8 字节，TIMESTAMP 占用 4 字节。选择时，跨时区应用可使用 TIMESTAMP，本地固定时间可用 DATETIME。</p><hr><ol start="8"><li>如何选择合适的数据类型以优化空间和性能？</li></ol><p>原则是 尽量小、精确、满足业务需求：</p><p>数字类型按值范围选择最小类型（TINYINT、SMALLINT、INT、BIGINT）。</p><p>字符类型固定长度用 CHAR，可变长度用 VARCHAR。</p><p>日期类型考虑是否需要跨时区，选择 TIMESTAMP 或 DATETIME。</p><p>减少冗余字段和大文本字段，利于缓存和索引效率。</p><h2 id="三、索引-🌟🌟🌟🌟" tabindex="-1">三、索引（🌟🌟🌟🌟） <a class="header-anchor" href="#三、索引-🌟🌟🌟🌟" aria-label="Permalink to &quot;三、索引（🌟🌟🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-2" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-2" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><ul><li><strong>B+ 树叶链表，范围查找快</strong></li><li><strong>聚簇主键存行，二级索引回表</strong></li><li><strong>覆盖索引全字段，无需回表</strong></li><li><strong>最左匹配，联合索引起作用</strong></li><li><strong>索引越多写越慢，选用高选择</strong></li><li><strong>函数类型转换，索引易失效</strong></li><li><strong>EXPLAIN 看 type、rows、key、Extra</strong></li><li><strong>ICP 下推，减少回表提效率</strong></li></ul><h3 id="必学资料-2" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-2" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/08%20%20%e7%b4%a2%e5%bc%95%ef%bc%9a%e6%8e%92%e5%ba%8f%e7%9a%84%e8%89%ba%e6%9c%af.md" target="_blank" rel="noreferrer">08 索引：排序的艺术</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/09%20%20%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e8%a1%a8%ef%bc%9a%e4%b8%87%e7%89%a9%e7%9a%86%e7%b4%a2%e5%bc%95.md" target="_blank" rel="noreferrer">09 索引组织表：万物皆索引</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/10%20%20%e7%bb%84%e5%90%88%e7%b4%a2%e5%bc%95%ef%bc%9a%e7%94%a8%e5%a5%bd%ef%bc%8c%e6%80%a7%e8%83%bd%e6%8f%90%e5%8d%87%2010%20%e5%80%8d%ef%bc%81.md" target="_blank" rel="noreferrer">10 组合索引：用好，性能提升 10 倍！</a></p><h3 id="面试题逐题回答-2" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-2" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>为什么 MySQL 使用 B+ 树而不是其他结构？</li></ol><p>MySQL 使用 B+ 树是因为它非常适合 磁盘存储和范围查询。B+ 树的叶子节点链表可以顺序访问，支持范围扫描；内节点只存储索引，减少磁盘 IO；高度平衡保证查找时间复杂度 O(log n)。相比 Hash 索引，B+ 树支持范围查询和排序，而 Hash 只适合等值查询。</p><hr><ol start="2"><li>B+ 树的优缺点？</li></ol><p>优点：</p><p>支持范围查询和排序。</p><p>磁盘 IO 少，高度平衡。</p><p>叶子节点链表可以快速遍历。</p><p>缺点：</p><p>写入和更新成本比 Hash 高。</p><p>维护复杂，需要分裂、合并节点。</p><hr><ol start="3"><li>InnoDB 的索引存储结构是什么？</li></ol><p>InnoDB 使用 聚簇索引存储数据，主键索引的叶子节点存储整行数据。非主键索引（辅助索引）叶子节点只存储主键值，查询非主键字段需回表访问聚簇索引。</p><hr><ol start="4"><li>什么是回表？为什么会回表？如何避免？</li></ol><p>回表是指查询使用二级索引时，需要通过主键再访问聚簇索引获取完整行数据。回表会增加 IO 开销。<br> 避免方式：使用 覆盖索引，即索引包含查询所需的所有列，这样可以直接从索引返回结果，无需访问聚簇索引。</p><hr><ol start="5"><li>什么是索引覆盖（Covering Index）？</li></ol><p>覆盖索引是指索引包含查询语句所需的全部字段，查询可以直接使用索引返回结果，不需要回表访问数据行。这不仅减少了 IO，也提高了查询性能。</p><hr><ol start="6"><li>什么是索引合并（Index Merge）？</li></ol><p>索引合并是 MySQL 查询优化器在执行查询时，将多个单列索引的结果进行 交集或并集，再返回符合条件的行。它可以提高多条件查询效率，但对高选择性索引效果更明显。</p><hr><ol start="7"><li>MySQL 有哪些索引类型？</li></ol><p>MySQL 索引类型主要有：</p><p>主键索引：唯一且非空，用作聚簇索引。</p><p>唯一索引：保证列值唯一，但可为空。</p><p>普通索引：无唯一性约束。</p><p>全文索引：用于全文搜索（MATCH ... AGAINST）。</p><p>前缀索引：对字符串前 N 个字符建立索引，节省空间。</p><hr><ol start="8"><li>聚簇索引与非聚簇索引的区别？</li></ol><p>聚簇索引：数据和索引存储在一起，叶子节点存储完整行数据。</p><p>非聚簇索引：叶子节点存储主键值，访问非主键列时需回表。<br> 聚簇索引适合主键查找，非聚簇索引适合辅助查询，但回表开销较高。</p><hr><ol start="9"><li>InnoDB 主键索引与二级索引的关系？</li></ol><p>二级索引的叶子节点存储主键值，通过主键去聚簇索引回表获取完整数据。也就是说，所有二级索引都依赖主键索引。</p><hr><ol start="10"><li>普通索引与唯一索引的区别？哪个更新性能更好？</li></ol><p>唯一索引保证列值唯一，需要维护额外约束，写入和更新成本略高；普通索引没有唯一性约束，更新性能更好。选择时可根据业务唯一性需求使用唯一索引。</p><hr><ol start="11"><li>为什么要建索引？索引有哪些代价？</li></ol><p>作用：提高查询效率，支持排序和分组。<br> 代价：增加写入和更新成本（INSERT/UPDATE/DELETE）。占用磁盘和内存空间。索引过多可能导致性能下降。</p><hr><ol start="12"><li>哪些字段适合建索引？哪些不适合？</li></ol><p>适合：高选择性字段、常用于查询条件、排序、分组的字段。<br> 不适合：低选择性字段（性别、状态）、频繁更新字段、大文本字段。</p><hr><ol start="13"><li>索引越多越好吗？</li></ol><p>不是，索引越多会增加写入成本、占用更多存储，可能导致性能下降。索引应根据查询场景精心设计。</p><hr><ol start="14"><li>哪些场景下索引反而会降低性能？</li></ol><p>高频写入和更新表。</p><p>查询条件使用函数或类型转换导致索引失效。</p><p>索引数量过多导致维护成本高。</p><hr><ol start="15"><li>查询语句一定会使用索引吗？</li></ol><p>不一定。优化器会根据表大小、索引选择性和统计信息决定是否使用索引。有时全表扫描比索引扫描更快。</p><hr><ol start="16"><li>哪些操作会导致索引失效？</li></ol><p>对列使用函数（如 DATE(col)）。</p><p>类型不匹配或隐式转换。</p><p>前置模糊匹配（LIKE &#39;%abc&#39;）。</p><p>OR 连接多个条件且无合适索引。</p><hr><ol start="17"><li>什么是最左匹配原则？</li></ol><p>联合索引 (a,b,c) 必须从最左列开始查询，才能使用索引。查询条件从中间或右侧列开始将导致索引失效。</p><hr><ol start="18"><li>什么是索引下推（ICP）？</li></ol><p>索引下推（Index Condition Pushdown）是存储引擎在扫描二级索引时，将 WHERE 条件部分下推到索引层过滤，减少回表行数，提高查询效率。</p><hr><ol start="19"><li>EXPLAIN 各字段代表什么？</li></ol><p>type：访问类型（ALL/INDEX/RANGE/REF/EQ_REF）。</p><p>rows：扫描的行数估算。</p><p>key：使用的索引。</p><p>Extra：额外信息，如 Using index 表示覆盖索引，Using where 表示回表后过滤。</p><hr><ol start="20"><li>EXPLAIN 中 Using index 与 Using where 的区别？</li></ol><p>Using index：查询完全使用索引，覆盖索引，无需回表。</p><p>Using where：查询需要访问数据行，索引无法覆盖所有字段，需要回表或额外过滤。</p><hr><ol start="21"><li>如何使用执行计划定位 SQL 性能问题？</li></ol><p>通过 EXPLAIN 查看访问类型、扫描行数、索引使用情况和 Extra 信息，判断是否全表扫描、索引命中率低、回表次数过多，进而优化索引或改写 SQL。</p><hr><ol start="22"><li>如果字段是 varchar 类型日期 &#39;20230922&#39;，where time=20230922（不加引号）会命中索引吗？为什么？</li></ol><p>不会命中索引，因为 20230922 是数字，MySQL 会隐式类型转换，将 time 列的 VARCHAR 转为数字或将数字转换为字符串，这会导致索引失效。正确写法应使用引号：WHERE time=&#39;20230922&#39;。</p><hr><ol start="23"><li>联合索引 (a, b, c) 时，哪些查询能走索引？</li></ol><p>WHERE a&gt;1 AND b=2 AND c&lt;3：可以走索引，遵循最左匹配原则，但 a&gt;1 是范围查询，b、c 会被部分使用或回表。</p><p>WHERE a=? AND b=? ORDER BY c：可以走联合索引，a、b 完全匹配，并且索引列 c 可用于排序优化，减少排序开销。</p><h2 id="四、事务-🌟🌟🌟🌟" tabindex="-1">四、事务（🌟🌟🌟🌟） <a class="header-anchor" href="#四、事务-🌟🌟🌟🌟" aria-label="Permalink to &quot;四、事务（🌟🌟🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-3" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-3" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><p><strong>事务特性</strong></p><ul><li>ACID 四性：原子一致隔离持久</li><li>Undo 回滚旧值保原子</li><li>Redo 顺序写保持久</li><li>锁配 MVCC 保隔离</li><li>Redis 弱事务，无回滚</li></ul><p><strong>隔离级别与并发问题</strong></p><ul><li>四级隔离：RU RC RR S</li><li>可重复读加间隙锁防幻</li><li>默认 RR，用 MVCC 实现</li><li>脏读未提，重读不一，幻行变多</li><li>串行化全锁，性能最低</li></ul><p><strong>MVCC 机制</strong></p><ul><li>MVCC 多版本，读无锁</li><li>创建删版号判可见</li><li>RC 新视图，RR 一视图</li><li>RC 并发高，RR 一致强</li><li>互联网常用 RC 提性能</li></ul><p><strong>事务日志与持久化</strong></p><ul><li>Undo 保回滚，Redo 保恢复</li><li>Undo 原子性，Redo 持久性</li><li>两阶段提交保双写一致</li><li>先 Redo 后 Binlog 再提交</li><li>Redo 顺序写，I/O 高效</li></ul><h3 id="必学资料-3" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-3" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/19-%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B" target="_blank" rel="noreferrer">事务简介</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/20-%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89" target="_blank" rel="noreferrer">Redo Log （上）</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/21-%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="noreferrer">Redo Log （下）</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/22-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89" target="_blank" rel="noreferrer">Undo Log（上）</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/23-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="noreferrer">Undo Log（下）</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC" target="_blank" rel="noreferrer">事务隔离级别</a></p><h3 id="面试题逐题回答-3" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-3" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><h4 id="事务特性" tabindex="-1">事务特性 <a class="header-anchor" href="#事务特性" aria-label="Permalink to &quot;事务特性&quot;">​</a></h4><ol><li>MySQL 事务的四大特性（ACID）是什么？</li></ol><p>事务的四大特性包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。<br> 原子性保证事务中的所有操作要么全部成功、要么全部失败；一致性保证事务前后数据状态必须合法；隔离性保证多个事务并发执行时互不干扰；持久性则保证事务一旦提交，其结果会永久保存到数据库中。</p><hr><ol start="2"><li>事务的原子性、隔离性、持久性是如何实现的？</li></ol><p>原子性通过 Undo Log 实现，记录事务修改前的旧值，当事务回滚时可恢复原状。<br> 隔离性依靠 锁机制 和 MVCC（多版本并发控制） 实现，确保不同事务读写操作互不影响。<br> 持久性通过 Redo Log 保证，Redo Log 记录事务提交后的修改内容，即使数据库崩溃，也能通过日志恢复数据。</p><hr><ol start="3"><li>MySQL 与 Redis 的事务机制有何不同？</li></ol><p>MySQL 的事务基于 ACID 特性，具备回滚、隔离和持久化能力；而 Redis 的事务更轻量，本质是命令队列（MULTI/EXEC），没有隔离性，也不支持回滚。Redis 的事务只保证命令的顺序执行，不保证中途失败可恢复，因此属于“弱事务机制”。</p><h4 id="隔离级别与并发问题" tabindex="-1">隔离级别与并发问题 <a class="header-anchor" href="#隔离级别与并发问题" aria-label="Permalink to &quot;隔离级别与并发问题&quot;">​</a></h4><ol><li>MySQL 支持哪些事务隔离级别？</li></ol><p>MySQL 支持四种标准的事务隔离级别：<br> 读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。</p><hr><ol start="2"><li>各隔离级别分别解决了哪些问题？</li></ol><p>读未提交：可能出现脏读、不可重复读、幻读。</p><p>读已提交：避免脏读，但仍会出现不可重复读和幻读。</p><p>可重复读：避免脏读和不可重复读，InnoDB 通过 MVCC 解决大部分幻读问题。</p><p>串行化：通过加锁彻底避免所有并发问题，但性能最差。</p><hr><ol start="3"><li>默认隔离级别是什么？如何实现？</li></ol><p>MySQL InnoDB 的默认隔离级别是 可重复读（Repeatable Read）。<br> 它通过 MVCC 实现一致性读，通过「当前读 + 间隙锁（Next-Key Lock）」避免大多数幻读场景。</p><hr><ol start="4"><li>脏读、不可重复读、幻读的区别？</li></ol><p>脏读：读到了未提交事务修改的数据。</p><p>不可重复读：同一事务多次读取同一行，结果不同。</p><p>幻读：同一查询条件下，前后读取到的行数不同（新增或删除了数据）。</p><hr><ol start="5"><li>串行化隔离级别如何实现？</li></ol><p>串行化通过强制事务 按顺序执行 来实现，所有读写操作都加锁（通常是表级锁），从而避免任何并发读写冲突。性能低，但隔离性最强。</p><hr><ol start="6"><li>可重复读级别如何解决幻读？是否完全避免？</li></ol><p>InnoDB 在可重复读级别下使用 MVCC + 间隙锁（Next-Key Lock）。<br> MVCC 解决了快照读下的幻读问题，而间隙锁用于当前读（如 SELECT ... FOR UPDATE）场景下防止插入新数据。<br> 但在某些特殊场景（如非一致性读或手动关闭间隙锁）下，仍可能出现幻读。</p><h4 id="mvcc-多版本并发控制" tabindex="-1">MVCC（多版本并发控制） <a class="header-anchor" href="#mvcc-多版本并发控制" aria-label="Permalink to &quot;MVCC（多版本并发控制）&quot;">​</a></h4><ol><li>什么是 MVCC？</li></ol><p>MVCC（Multi-Version Concurrency Control）是一种多版本并发控制机制。它让读操作无需加锁即可读取数据的历史版本，从而提高并发性能。每行记录都有隐藏字段：创建版本号和删除版本号，用来判断对事务是否可见。</p><hr><ol start="2"><li>MVCC 如何判断行记录是否对事务可见？</li></ol><p>当事务执行查询时，InnoDB 会根据当前事务的 Read View（快照视图）判断记录是否可见：</p><p>若记录的创建版本号 ≤ 当前事务 ID 且删除版本号为空或 &gt; 当前事务 ID，则该记录可见。</p><p>否则说明该行被其他事务修改或删除，不可见。</p><hr><ol start="3"><li>读已提交与可重复读隔离级别的 MVCC 差异？</li></ol><p>在 读已提交（RC） 下，每次执行 SELECT 都会生成新的 Read View，读取最新提交版本。<br> 在 可重复读（RR） 下，整个事务只生成一次 Read View，因此多次查询结果一致。</p><hr><ol start="4"><li>为什么互联网公司常用读已提交？</li></ol><p>读已提交（RC）在高并发场景下性能更好，避免长时间持有快照视图导致的版本链过长问题。<br> 同时，业务系统往往对“可重复读”的一致性要求不高，轻微的并发差异可以通过业务逻辑容忍或补偿。</p><h4 id="事务日志与持久化" tabindex="-1">事务日志与持久化 <a class="header-anchor" href="#事务日志与持久化" aria-label="Permalink to &quot;事务日志与持久化&quot;">​</a></h4><ol><li>什么是 Undo Log？它的作用是什么？</li></ol><p>Undo Log 是用于记录事务操作前数据状态的日志。<br> 它的主要作用是支持事务回滚和 MVCC 版本控制：回滚时可恢复原始数据，MVCC 读取旧版本时也依赖 Undo Log。</p><hr><ol start="2"><li>Undo Log 与 Redo Log 如何共同实现事务一致性？</li></ol><p>Undo Log 保证原子性，Redo Log 保证持久性。<br> 事务提交时先写入 Redo Log，再写入 Binlog，崩溃恢复时通过 Redo Log 重放提交数据，或根据 Undo Log 回滚未提交事务，从而确保一致性。</p><hr><ol start="3"><li>什么是两阶段提交？其作用是什么？</li></ol><p>两阶段提交（2PC）用于保证 Redo Log 与 Binlog 数据的一致性。<br> 阶段一：准备阶段，先写入 Redo Log 并标记为 prepare；<br> 阶段二：提交阶段，写入 Binlog 后标记 Redo Log 为 commit。<br> 这样即使崩溃，也能根据两者状态判断事务是否成功提交。</p><hr><ol start="4"><li>事务提交过程中 Redo Log 与 Binlog 的写入顺序？</li></ol><p>事务提交时，InnoDB 会先写 Redo Log（prepare 状态），再写 Binlog，最后将 Redo Log 标记为 commit。<br> 此顺序保证在系统崩溃时，能够根据 Redo Log 与 Binlog 的状态安全恢复。</p><hr><ol start="5"><li>Redo Log 为什么采用顺序写？</li></ol><p>Redo Log 使用顺序写是为了减少磁盘寻址开销、提高写入性能。<br> 顺序写的 I/O 效率远高于随机写，加上 InnoDB 的写缓冲机制（Log Buffer），能在保证持久性的同时提升事务吞吐量。</p><h2 id="五、锁机制-🌟🌟🌟" tabindex="-1">五、锁机制（🌟🌟🌟） <a class="header-anchor" href="#五、锁机制-🌟🌟🌟" aria-label="Permalink to &quot;五、锁机制（🌟🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-4" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-4" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><p><strong>锁机制</strong></p><ul><li>六类锁：表行意向间隙 Next-Key、MDL</li><li>行锁两类：共享 S、排他 X</li><li>间隙锁锁空隙，Next-Key“记录+范围”</li><li>UPDATE 无 WHERE，全表上 X</li><li>未命中索引，扫描全表上锁</li><li>同行不同列，行锁仍冲突</li><li>FOR UPDATE 扫描范围会锁多行</li><li>行锁随索引定，没命中则全表锁</li></ul><p><strong>死锁与并发</strong></p><ul><li>乐观锁靠版本，失败重试</li><li>悲观锁先加锁，防并发写</li><li>死锁是循环等</li><li>等待图查死锁，自动回滚</li><li>避死锁靠顺序、小事务、用索引</li></ul><h3 id="必学资料-4" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-4" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/25-%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81" target="_blank" rel="noreferrer">锁</a></p><h3 id="面试题逐题回答-4" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-4" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><h4 id="锁分类与原理" tabindex="-1">锁分类与原理 <a class="header-anchor" href="#锁分类与原理" aria-label="Permalink to &quot;锁分类与原理&quot;">​</a></h4><ol><li>MySQL 有哪些锁？（表锁、行锁、意向锁、间隙锁、Next-Key Lock、MDL）</li></ol><p>在 MySQL 中，不同层面提供了多种类型的锁，目的是兼顾并发性能与数据一致性。首先，从操作粒度来看，有表锁与行锁：表锁作用于整个表，常见于 MyISAM，引入成本低但并发能力弱；行锁则由 InnoDB 提供，以记录为粒度，能显著提升高并发下的吞吐量。其次，InnoDB 使用意向锁来快速判断表锁与行锁的兼容性，使加锁判断的成本保持常量级。为了避免幻读，InnoDB 引入了间隙锁与 Next-Key Lock：前者用于锁定记录之间的空隙，后者是“记录锁 + 间隙锁”的组合，确保范围查询的隔离性。除此之外，还存在元数据锁（MDL），用于在 DDL 与 DML 并发时保护表结构安全。整体来看，这套锁体系保证了 MySQL 在不同场景下的隔离性、并发性与一致性。</p><hr><ol start="2"><li>InnoDB 的行级锁有哪些？</li></ol><p>InnoDB 基于索引实现记录级锁，核心包括共享锁（S）与排他锁（X）。共享锁允许多个事务同时读取记录，但禁止对记录进行修改；排他锁则确保只有当前事务能够读或写记录，从而保护更新操作的安全性。除此之外，行级锁并不仅限于具体记录：在范围查询下，InnoDB 会额外使用间隙锁与 Next-Key Lock 来锁定范围，以保证可重复读隔离级别下的一致性读取。在实际应用中，行锁依赖索引，因此设计合适的索引结构直接决定加锁范围与并发性能。</p><hr><ol start="3"><li>间隙锁（Gap Lock）和 Next-Key Lock 的区别？</li></ol><p>两者都是为了防止范围查询中的幻读问题，但作用范围存在差异。间隙锁仅锁定记录之间的区间，并不锁定具体记录本身，因此主要用于阻止其他事务在锁定区间内插入新记录。而 Next-Key Lock 则由记录锁和间隙锁共同构成，不仅锁定记录本身，还覆盖该记录前的间隙，形成半开半闭的区间。由于其覆盖范围更大，可重复度隔离级别下的 InnoDB 会默认使用 Next-Key Lock，从而保证范围查询的稳定性。这种机制避免了其他事务插入新行导致的幻读，同时保证读取结果在事务生命周期内一致。</p><hr><ol start="4"><li>一条 UPDATE 不带 WHERE 会加什么锁？</li></ol><p>不带 WHERE 条件的 UPDATE 会导致 InnoDB 进行全表扫描，因此对每一条记录加排他行锁（X 锁），并且由于锁遍整个表，会自动持有相应的意向排他锁。这种加锁方式相当于对整个表加上强制性的写锁，导致其他事务无法对表中的任意记录执行读写操作，因此会严重影响并发性能。在生产环境中，应避免在高峰期执行无条件 UPDATE，否则容易造成大面积阻塞。</p><hr><ol start="5"><li>带 WHERE 但未命中索引，会加什么锁？</li></ol><p>未命中索引的 WHERE 条件会让 SQL 执行退化为全表扫描，此时 InnoDB 会逐条读取记录，并对扫描到的每条记录加排他锁。这种方式与无 WHERE UPDATE 相似，都会造成大量锁持有时间较长，导致并发性能下降。尤其是在大表场景中，此类 SQL 可能引发锁等待、阻塞甚至死锁。因此设计良好的索引结构不仅提高查询性能，还能减少锁时间与锁竞争，是高并发系统中非常关键的优化点。</p><hr><ol start="6"><li>两条事务更新同一行记录会加什么锁？</li></ol><p>两条事务更新同一条记录时，都会尝试对该记录加排他锁。第一个事务成功加锁后，第二个事务会进入等待状态，直到前者提交或回滚。由于排他锁之间是互斥的，这种写写冲突属于典型的行级竞争情形。为了降低这类冲突的概率，应尽量将热数据拆分、使用分库分表、或采用缓存层缓冲写入压力。</p><hr><ol start="7"><li>更新同一行的不同字段，会加锁冲突吗？</li></ol><p>会造成冲突。InnoDB 锁的粒度是“行”，而不是“字段”。因此无论更新某一列还是多列，事务在更新时都需要对整条记录加排他锁。结果是，只要两个事务操作的是同一条记录，即便更新字段不一致，也会产生锁竞争。这也是为什么数据库设计中强调避免热点行，以及为何无法通过列级拆分减少并发冲突。</p><hr><ol start="8"><li>SELECT ... FOR UPDATE 会锁多行吗？为什么？</li></ol><p>在 InnoDB 中，SELECT FOR UPDATE 会根据查询条件锁定扫描到的记录。加锁范围由索引范围决定，因此不仅实际返回的记录会加锁，符合扫描范围但未返回的记录也可能被加锁。若是范围查询，还会触发间隙锁或 Next-Key Lock，因此最终加锁范围可能远大于返回行数。在索引命中不佳或全表扫描时，加锁范围甚至可能扩大到整个表，从而显著影响并发能力。</p><hr><ol start="9"><li>行锁的加锁范围是如何确定的？（如范围查询）</li></ol><p>行锁的核心依据是索引。命中唯一索引时，锁定范围只包含特定记录，开销最低。而在范围查询中，InnoDB 需要保证可重复读隔离级别，因此采用 Next-Key Lock，对目标记录及其前后间隙加锁，确保范围稳定。如果查询未命中索引，则退化为全表扫描，对所有扫描到的记录加锁，导致锁范围显著扩大。因此，索引设计直接控制加锁范围，是保障并发能力的核心因素之一。</p><hr><ol start="10"><li>什么是乐观锁？MySQL 如何实现？</li></ol><p>乐观锁假设并发冲突不频繁，因此不会在数据读取阶段加锁，而是在更新时检查数据是否被修改。MySQL 中常见的实现方式是利用 version 字段或更新时间字段，通过条件更新保证数据一致性：例如 <code>UPDATE ... WHERE id=? AND version=?</code>。如果更新行数为 0，说明其他事务已经修改过数据，此时需要重试或给出冲突提示。乐观锁适合读多写少的场景，避免了悲观锁的大量阻塞开销。</p><hr><ol start="11"><li>什么是悲观锁？</li></ol><p>悲观锁假设冲突必然发生，因此会在数据读取或修改前就提前加锁，阻止其他事务并发修改。例如 InnoDB 的 UPDATE、SELECT FOR UPDATE 与 LOCK IN SHARE MODE 均属于悲观锁实现方式。悲观锁适合写竞争较激烈的场景，但会带来大量阻塞与等待，需要合理控制事务范围。</p><hr><ol start="12"><li>什么是死锁？</li></ol><p>死锁指多个事务持有部分锁资源，同时等待对方释放所需资源，形成循环等待链，导致所有相关事务无法继续执行。如事务 A 等 B 的锁，B 又等待 A 的锁。在高并发系统中，死锁是难以避免的现象，因此数据库必须具备自动检测与恢复机制。</p><hr><h4 id="死锁与冲突分析" tabindex="-1">死锁与冲突分析 <a class="header-anchor" href="#死锁与冲突分析" aria-label="Permalink to &quot;死锁与冲突分析&quot;">​</a></h4><ol start="13"><li>InnoDB 如何检测死锁？</li></ol><p>InnoDB 通过构建等待图来分析事务之间的依赖关系。当图中出现循环依赖时，即表示发生了死锁。此时 InnoDB 会主动选择一个成本较低（通常是修改数据量较少）的事务进行回滚，从而打破循环，使其他事务得以继续执行。这种自动检测机制能及时恢复系统健康，避免事务永久阻塞。</p><hr><ol start="14"><li>如何排查死锁问题？</li></ol><p>排查死锁最常用的方法是执行 <code>SHOW ENGINE INNODB STATUS</code>，查看最近一次死锁的详细信息，包括参与的 SQL、锁类型、等待链等。如果开启 <code>innodb_print_all_deadlocks</code>，所有死锁会记录到日志，便于历史分析。根据日志可以识别是否为索引缺失、访问顺序不一致或大事务导致，从而针对性优化。</p><hr><ol start="15"><li>如何避免死锁？</li></ol><p>死锁无法完全避免，但可以减少其发生概率。常见策略包括：保证事务访问顺序一致，避免产生循环依赖；将大事务拆解为小事务，缩短锁持有时间；为查询增加合适的索引，避免全表扫描扩大加锁范围；充分利用缓存减少数据库写压力；尽量避免在事务中执行复杂或耗时操作。在良好设计下，死锁的影响可以被降低到可控范围。</p><h2 id="六、日志系统-🌟🌟🌟" tabindex="-1">六、日志系统（🌟🌟🌟） <a class="header-anchor" href="#六、日志系统-🌟🌟🌟" aria-label="Permalink to &quot;六、日志系统（🌟🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-5" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-5" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><ul><li>三类日志：Redo、Undo、Binlog</li><li>Redo 物理恢复，Binlog 逻辑同步</li><li>崩溃恢复用 Redo，顺序写性能高</li><li>Binlog 三种：Statement、Row、Mixed</li><li>Redo 先写 Log Buffer，再刷磁盘</li><li>Redo 保障持久性+MVCC，支持回滚</li><li>两阶段提交保 Redo 与 Binlog 一致</li><li>Redo 刷盘策略：每事务、每秒、异步</li></ul><h3 id="必学资料-5" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-5" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><ul><li>见事务部分</li></ul><h3 id="面试题逐题回答-5" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-5" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>MySQL 有哪些日志？（Redo、Undo、Binlog）</li></ol><p>MySQL 核心日志包括 Redo、Undo 和 Binlog。Redo 用于崩溃恢复，记录已提交事务的物理变化；Undo 用于事务回滚和 MVCC，保存修改前的旧值；Binlog 用于主从复制和审计，记录逻辑层操作顺序，实现数据同步和审计。</p><hr><ol start="2"><li>Redo Log 与 Binlog 的区别与应用场景？</li></ol><p>Redo Log 是物理日志，保证事务持久性和崩溃恢复；Binlog 是逻辑日志，记录 SQL 执行顺序，用于复制和审计。Redo 适用于本地恢复，Binlog 用于主从同步和数据回溯。</p><hr><ol start="3"><li>为什么崩溃恢复使用 Redo Log 而不是 Binlog？</li></ol><p>Redo Log 保存物理数据修改，且顺序写性能高，可快速恢复未写入磁盘的事务；Binlog 逻辑层次高，可能存在事务未提交或顺序不完整，效率低且依赖事务提交，无法保证崩溃恢复原子性。</p><hr><ol start="4"><li>Binlog 的三种格式（statement / row / mixed）？</li></ol><p>Statement 格式记录 SQL 语句；Row 格式记录具体行数据变化；Mixed 格式结合两者，默认使用 Statement，遇复杂语句使用 Row。选择影响复制精确性与性能。</p><hr><ol start="5"><li>Redo Log 如何实现持久化？</li></ol><p>Redo Log 先写入内存 Log Buffer，再异步刷盘到磁盘，根据策略（innodb_flush_log_at_trx_commit）决定同步时机，保证数据持久性且提升写入效率。</p><hr><ol start="6"><li>Redo Log 除了崩溃恢复还有哪些作用？</li></ol><p>Redo Log 支持事务持久性、保障原子性，并结合 Undo 实现 MVCC 版本控制，提高并发读性能，是 InnoDB 事务引擎核心机制。</p><hr><ol start="7"><li>为什么需要两阶段提交？</li></ol><p>两阶段提交保证 Redo Log 与 Binlog 的一致性。先写 Redo 并标记 prepare，再写 Binlog，最后提交 Redo。即使崩溃，也能判断事务是否成功，确保数据一致。</p><hr><ol start="8"><li>Redo Log 的三种刷盘策略？</li></ol><p>每事务提交同步刷盘（最安全）；</p><p>每秒刷盘（性能与安全平衡）；</p><p>不刷盘（性能高但可能丢失数据），可通过 Log Buffer 异步写入提升性能。</p><h2 id="七、性能优化-🌟🌟" tabindex="-1">七、性能优化（🌟🌟） <a class="header-anchor" href="#七、性能优化-🌟🌟" aria-label="Permalink to &quot;七、性能优化（🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-6" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-6" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><p>**性能优化 **</p><ul><li>判断索引：EXPLAIN 看 key/type/rows</li><li>定位慢 SQL：slow_query_log + 分析工具</li><li>优化慢 SQL：索引、改写、拆表、分页</li><li>type=ALL/rows 大：全表扫描，索引缺失</li><li>SQL 慢但索引没问题：检查 IO、锁、join</li><li>深分页优化：延迟关联、keyset、预聚合</li><li>大表删改：分批、加索引、临时表、拆分</li><li>Performance Schema：分析慢 SQL、锁、IO</li><li>查询缓存废弃：高并发易失效，buffer pool 替代</li></ul><h3 id="必学资料-6" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-6" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><h3 id="面试题逐题回答-6" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-6" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>如何判断 SQL 是否走索引？</li></ol><p>可以通过 <code>EXPLAIN</code> 查看查询执行计划，关注 key、key_len、rows 等字段。如果 key 显示使用索引且 type 非 ALL，说明走了索引。结合 <code>SHOW PROFILE</code> 或 <code>EXPLAIN ANALYZE</code> 可进一步确认索引命中情况。</p><hr><ol start="2"><li>如何定位慢 SQL？如何使用 slow_query_log？</li></ol><p>开启 <code>slow_query_log</code> 并设置 <code>long_query_time</code>，MySQL 会记录执行超过阈值的 SQL。结合 <code>mysqldumpslow</code> 或 <code>pt-query-digest</code> 分析日志，可找出耗时最长或频繁执行的 SQL。</p><hr><ol start="3"><li>如何优化慢 SQL？</li></ol><p>优化慢 SQL 可从索引优化、查询改写、拆分大表、分页优化、避免 SELECT * 和子查询入手。同时关注表结构、统计信息和事务设计，减少全表扫描与锁等待。</p><hr><ol start="4"><li>explain 中 type=ALL、rows 很大说明什么问题？</li></ol><p>type=ALL 表示全表扫描，rows 大说明扫描行数多，可能没有使用索引或索引选择不当。这通常是慢查询的主要原因，需要优化索引或改写 SQL。</p><hr><ol start="5"><li>SQL 和索引都没问题但查询仍慢怎么办？（IO / 锁等待 / join 缓慢）</li></ol><p>需要从系统层面排查：查看 IO 是否瓶颈、锁等待是否严重、join 是否产生临时表或文件排序。可使用 <code>SHOW ENGINE INNODB STATUS</code>、Performance Schema 或监控工具分析。</p><hr><ol start="6"><li>深分页查询如何优化？（limit offset）</li></ol><p>深分页用大 offset 会扫描大量数据，可改为延迟关联分页（where id &gt; 上一页最大 id）、使用 keyset 分页或预聚合，避免全表扫描与排序。</p><hr><ol start="7"><li>大表删除或更新的风险与优化方式？</li></ol><p>大表 DELETE/UPDATE 会锁表或生成大量 undo/redo，可能导致阻塞或日志膨胀。优化方式包括分批处理、加索引条件、使用临时表或按时间/主键拆分操作。</p><hr><ol start="8"><li>如何分析 Performance Schema？</li></ol><p>Performance Schema 提供 SQL、等待事件、锁、IO 等监控信息。可通过查询 <code>events_statements_summary_by_digest</code>、<code>events_waits_summary_by_instance</code> 等表，分析慢 SQL、锁等待和资源瓶颈。</p><hr><ol start="9"><li>MySQL 查询缓存为什么被废弃？</li></ol><p>查询缓存仅缓存结果集，写表时需清空相关缓存，高并发下频繁失效，维护成本高。现代 InnoDB 通过 buffer pool、索引和缓存层实现更高效的性能，因此查询缓存被废弃。</p><h2 id="八、高可用与扩展-🌟🌟" tabindex="-1">八、高可用与扩展（🌟🌟） <a class="header-anchor" href="#八、高可用与扩展-🌟🌟" aria-label="Permalink to &quot;八、高可用与扩展（🌟🌟）&quot;">​</a></h2><h3 id="答题-背诵技巧-7" tabindex="-1">答题/背诵技巧 <a class="header-anchor" href="#答题-背诵技巧-7" aria-label="Permalink to &quot;答题/背诵技巧&quot;">​</a></h3><ul><li>主从复制：主写 Binlog → IO 线程 → 从库 SQL 执行</li><li>复制模式：异步 / 半同步 / 全同步</li><li>默认模式：异步，提交不等从库确认</li><li>主从延迟：大事务、网络、从库性能，优化 SQL 和硬件</li><li>半同步：主库等待至少一个从库收到确认</li><li>读写分离：写主库，读从库 + 负载均衡</li><li>主库宕机 failover：提升从库，重建同步</li><li>分库分表：拆库拆表减压力，提高性能</li><li>分表：单表大数据量；分库：单库压力大</li><li>问题与解决：分布式事务、全局 ID、跨库查询、路由层设计</li></ul><h3 id="必学资料-7" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-7" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/23%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E8%90%BD%E5%9C%B0%EF%BC%9F.md" target="_blank" rel="noreferrer">23 读写分离如何在业务中落地？</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/19%20%20%E9%AB%98%E5%8F%AF%E7%94%A8%E5%A5%97%E4%BB%B6%EF%BC%9A%E9%80%89%E6%8B%A9%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%8C%E4%BD%A0%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%EF%BC%9F.md" target="_blank" rel="noreferrer">19 高可用套件：选择这么多，你该如何选？</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/24%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F.md" target="_blank" rel="noreferrer">24 为什么需要分库分表，如何实现？</a></p><h3 id="面试题逐题回答-7" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-7" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>MySQL 主从复制的基本过程？</li></ol><p>主库将写操作记录到 Binlog，IO 线程读取 Binlog 并发送给从库，从库的 SQL 线程执行这些日志，从而保持数据同步，实现异地备份和读写分离。</p><hr><ol start="2"><li>有哪几种复制模式？（异步 / 半同步 / 全同步）</li></ol><p>复制模式包括异步、半同步和全同步。异步复制主库提交后不等待从库确认；半同步复制等待至少一个从库确认提交；全同步复制要求所有从库确认后主库才完成提交。</p><hr><ol start="3"><li>默认复制模式是什么？</li></ol><p>MySQL 默认是异步复制，提交事务无需等待从库确认，适合高性能写场景，但可能存在主从数据短暂不一致。</p><hr><ol start="4"><li>主从延迟的常见原因与解决方案？</li></ol><p>常见原因包括大事务、网络延迟、从库性能不足、锁等待。解决方案有优化 SQL、增加从库数量、提升硬件、分库分表、异步刷盘等。</p><hr><ol start="5"><li>什么是半同步复制？</li></ol><p>半同步复制指主库提交事务后，会等待至少一个从库收到并写入 Relay Log 才确认提交，兼顾性能和数据安全性，降低数据丢失风险。</p><hr><ol start="6"><li>主从架构下如何实现读写分离？</li></ol><p>通过应用层或中间件将写操作定向到主库，读操作分发到从库，同时结合负载均衡和一致性策略，提升读吞吐量并减轻主库压力。</p><hr><ol start="7"><li>主库宕机后如何恢复？（failover 机制）</li></ol><p>可通过监控发现主库宕机，将从库提升为主库，并重新配置其他从库同步，保证系统继续提供服务。自动化工具如 MHA、Orchestrator 可实现快速 failover。</p><hr><ol start="8"><li>什么是分库分表？</li></ol><p>分库分表是将数据按业务或规则拆分到多个库或表，减小单库/表数据量，提高读写性能和系统扩展性。</p><hr><ol start="9"><li>什么时候需要分表？什么时候需要分库？</li></ol><p>当单表数据量巨大、查询和写入压力大时需要分表；当单库容量或并发到达瓶颈时需要分库。分表侧重水平拆表，分库侧重数据库层面扩展。</p><hr><ol start="10"><li>分库分表后常见问题及解决方案</li></ol><ul><li>分布式事务：可用柔性事务、业务幂等、两阶段提交或中间件协调。</li><li>全局唯一 ID：使用雪花算法、UUID 或数据库自增 + 前缀。</li><li>跨库查询与聚合：通过中间件、应用层汇总，或拆分报表任务。</li><li>路由层设计：通过规则或中间件路由 SQL 到对应库表，保证查询正确性和性能。</li></ul><h2 id="九、综合与思考题-🌟🌟" tabindex="-1">九、综合与思考题（🌟🌟） <a class="header-anchor" href="#九、综合与思考题-🌟🌟" aria-label="Permalink to &quot;九、综合与思考题（🌟🌟）&quot;">​</a></h2><h3 id="必学资料-8" tabindex="-1">必学资料 <a class="header-anchor" href="#必学资料-8" aria-label="Permalink to &quot;必学资料&quot;">​</a></h3><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/15-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89" target="_blank" rel="noreferrer">Explain（上）</a></p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/16-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89" target="_blank" rel="noreferrer">Explain（下）</a></p><h3 id="面试题逐题回答-8" tabindex="-1">面试题逐题回答 <a class="header-anchor" href="#面试题逐题回答-8" aria-label="Permalink to &quot;面试题逐题回答&quot;">​</a></h3><ol><li>请结合具体 SQL，分析一次慢查询的排查与优化过程。</li></ol><p>首先通过 slow_query_log 定位慢 SQL，例如 <code>SELECT * FROM orders WHERE status=&#39;pending&#39; ORDER BY created_at DESC LIMIT 1000</code>。用 EXPLAIN 查看执行计划，发现全表扫描。优化方法：为 status + created_at 建复合索引，改写查询避免 SELECT *，增加分页或延迟关联查询，最终查询只扫描必要行并利用索引排序，提高性能。</p><hr><ol start="2"><li>如何设计一张支持高并发写入的日志表？</li></ol><p>日志表设计应采用 InnoDB，主键建议自增或雪花 ID，减少热点行；列尽量少，避免 TEXT/BLOB；支持批量插入；可按日期或模块分表，结合分区表减少单表压力，结合异步写入或队列缓冲高并发流量。</p><hr><ol start="3"><li>解释一次 MySQL 事务的完整执行过程（含 redo、undo、binlog）。</li></ol><p>事务开始后修改数据，生成 Undo Log 保存旧值，便于回滚；修改写入 Buffer Pool，同时记录 Redo Log，用于崩溃恢复；提交时先刷 Binlog，再刷 Redo Log 提交；事务提交后，Undo Log 保留用于 MVCC 读取，Redo Log 可清理，确保 ACID 一致性与持久性。</p><hr><ol start="4"><li>如果一个表写入量巨大，如何防止表膨胀与性能下降？</li></ol><p>可采用分表分库、按时间或业务模块拆表，使用分区表；定期归档历史数据；控制索引数量，避免更新热点索引；分批写入减少锁竞争；结合缓存缓冲热点查询和写入压力，保持表体积与查询性能稳定。</p><hr><ol start="5"><li>MySQL 的常见性能调优手段有哪些？（索引、SQL、缓存、分表、参数）</li></ol><p>包括优化索引结构和覆盖索引、改写慢 SQL、减少 SELECT *、利用缓存（Redis/应用层）、分库分表、参数调优（innodb_buffer_pool_size、flush_log_at_trx_commit）、优化事务和锁策略，以及监控慢查询与性能指标。</p><hr><ol start="6"><li>线上 MySQL CPU 飙高，你的排查步骤是什么？</li></ol><p>首先用 top/iostat 查看系统负载，确认 CPU 占用来源；结合 Performance Schema 或 SHOW PROCESSLIST 分析慢 SQL 或锁等待；检查查询计划 EXPLAIN，分析是否全表扫描；观察索引使用和缓存命中率；必要时开启慢查询日志分析热点 SQL，并考虑 SQL 优化或增加硬件资源。</p>',426)])])}const A=e(i,[["render",t]]);export{B as __pageData,A as default};
